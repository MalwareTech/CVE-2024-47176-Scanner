#!/usr/bin/env python3
import socket
import ipaddress
import argparse
import threading
import time
import signal
import sys
import os
from http.server import BaseHTTPRequestHandler, HTTPServer
from logging.handlers import RotatingFileHandler
from concurrent.futures import ThreadPoolExecutor
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# A function for generating a timestamp
def timestamp():
    return time.strftime("%Y-%m-%d %H:%M:%S")

# Custom class for handling HTTP requests from cups-browsed instances
class CupsCallbackRequest(BaseHTTPRequestHandler):
    def log_message(self, format, *args):
        log_line = f'[{timestamp()}] {self.address_string()} - {format % args} ' \
                   f'{self.headers.get("User-Agent", "Unknown")}\n'
        self.server.access_log.write(log_line.encode('utf-8'))
        self.server.access_log.flush()

    def log_raw_request(self):
        raw_request = f'[{timestamp()}]\n{self.requestline}\r\n'
        raw_request += ''.join(f"{key}: {value}\r\n" for key, value in self.headers.items())

        content_length = int(self.headers.get('Content-Length', 0))
        if content_length > 0:
            raw_body = self.rfile.read(content_length)
            self.server.request_log.write(raw_request.encode('utf-8') + b'\r\n' + raw_body + b'\r\n\r\n')
        else:
            self.server.request_log.write(raw_request.encode('utf-8'))
        self.server.request_log.flush()

    def send_static_response(self):
        self.send_response(200, 'OK')
        self.send_header('Content-Type', 'text/plain')
        self.end_headers()
        self.wfile.write(b'This is a benign server used for testing cups-browsed vulnerability CVE-2024-47176')

    def do_GET(self):
        self.send_static_response()

    def do_POST(self):
        if self.path.startswith('/printers/'):
            ip, port = self.client_address
            logging.info(f'received callback from vulnerable device: {ip} - {self.headers.get("User-Agent", "Unknown")}')
            self.server.cups_log.write(f'[{timestamp()}] {ip}:{port} - {self.headers["User-Agent"]} - {self.path}\n')
            self.server.cups_log.flush()
            self.log_raw_request()

        self.send_static_response()

# Custom class for adding file logging capabilities to HTTPServer class with log rotation
class CupsCallbackHTTPServer(HTTPServer):
    def __init__(self, server_address, handler_class, log_dir='logs'):
        super().__init__(server_address, handler_class)
        if not os.path.exists(log_dir):
            os.makedirs(log_dir)

        # Create log files with rotation (5MB max, keep up to 5 backups)
        self.access_log = RotatingFileHandler(f'{log_dir}/access.log', maxBytes=5*1024*1024, backupCount=5)
        self.request_log = open(f'{log_dir}/requests.log', 'ab')
        self.cups_log = open(f'{log_dir}/cups.log', 'a')

    def shutdown(self):
        logging.info('Shutting down the server and closing log files...')
        self.access_log.close()
        self.request_log.close()
        self.cups_log.close()
        super().shutdown()

# Start the callback server to receive callbacks from vulnerable cups-browsed instances
def start_server(callback_server):
    host, port = callback_server.split(':')
    port = int(port)

    if port < 1 or port > 65535:
        raise RuntimeError(f'invalid callback server port: {port}')

    server_address = (host, port)
    _httpd = CupsCallbackHTTPServer(server_address, CupsCallbackRequest)
    logging.info(f'callback server running on port {host}:{port}...')

    server_thread = threading.Thread(target=_httpd.serve_forever)
    server_thread.daemon = True
    server_thread.start()

    return _httpd

# Multi-threaded scanning of IP ranges using ThreadPoolExecutor
def scan_range(ip_range, callback_server):
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_callback = f'0 3 http://{callback_server}/printers/cups_vulnerability_scan'.encode('utf-8')
    ip_range = list(ipaddress.ip_network(ip_range))

    if len(ip_range) < 1:
        raise RuntimeError("error: invalid ip range")

    logging.info(f'scanning range: {ip_range[0]} - {ip_range[-1]}')

    for ip in ip_range:
        ip = str(ip)
        try:
            udp_socket.sendto(udp_callback, (ip, 631))
            logging.debug(f'Sent callback to {ip}')
        except socket.error as e:
            logging.error(f"Error sending to {ip}: {e}")

def concurrent_scan(target_ranges, callback_server):
    with ThreadPoolExecutor(max_workers=10) as executor:
        executor.map(lambda target: scan_range(target, callback_server), target_ranges)

# Handle CTRL + C abort
def signal_handler(signal, frame, httpd):
    logging.info('Shutting down server...')
    httpd.shutdown()
    sys.exit(0)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        prog='python3 cups_scanner.py',
        description='Uses the callback mechanism of CVE-2024-47176 to identify vulnerable cups-browsed instances',
        usage='python3 cups_scanner.py --targets 192.168.0.0/24 --callback 192.168.0.1:1337'
    )

    parser.add_argument('--callback', required=True, dest='callback_server',
                        help='the host:port to host the callback server on (must be reachable from target network) '
                             'example: --callback 192.168.0.1:1337')

    parser.add_argument('--targets', required=True, dest='target_ranges',
                        help='a comma separated list of ranges '
                             'example: --targets 192.168.0.0/24,10.0.0.0/8')

    parser.add_argument('--verbose', action='store_true', help='enable verbose output')

    args = parser.parse_args()

    try:
        logging.info(f'starting callback server on {args.callback_server}')
        httpd = start_server(args.callback_server)
        signal.signal(signal.SIGINT, lambda sig, frame: signal_handler(sig, frame, httpd))

        targets = args.target_ranges.split(',')
        logging.info('starting concurrent scan')
        concurrent_scan(targets, args.callback_server)

        logging.info('scan done, use CTRL + C to stop server')
        while True:
            time.sleep(1)

    except RuntimeError as e:
        logging.error(e)
