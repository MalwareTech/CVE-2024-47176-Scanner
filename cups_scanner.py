#!/usr/bin/env python3
import socket
import ipaddress
import argparse
import threading
import time
import signal
import sys
import os
from http.server import BaseHTTPRequestHandler, HTTPServer
from logging.handlers import RotatingFileHandler
from concurrent.futures import ThreadPoolExecutor
import logging
import ssl

# Set up logging
def setup_logger(name, log_file, level=logging.INFO):
    """Function to setup a logger with RotatingFileHandler."""
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    handler = RotatingFileHandler(log_file, maxBytes=5*1024*1024, backupCount=5)
    handler.setFormatter(formatter)

    logger = logging.getLogger(name)
    logger.setLevel(level)
    logger.addHandler(handler)
    
    return logger

# Ensure logs directory exists
os.makedirs('logs', exist_ok=True)

# Set up access, request, and cups loggers
access_logger = setup_logger('access_log', 'logs/access.log')
request_logger = setup_logger('request_log', 'logs/requests.log')
cups_logger = setup_logger('cups_log', 'logs/cups.log')

def timestamp():
    return time.strftime("%Y-%m-%d %H:%M:%S")

class CupsCallbackRequest(BaseHTTPRequestHandler):
    def log_message(self, format, *args):
        log_line = f'{self.address_string()} - {format % args} {self.headers.get("User-Agent", "Unknown")}'
        access_logger.info(log_line)

    def log_raw_request(self):
        raw_request = f'{self.requestline}\r\n'
        raw_request += ''.join(f"{key}: {value}\r\n" for key, value in self.headers.items())

        content_length = int(self.headers.get('Content-Length', 0))
        if content_length > 0:
            raw_body = self.rfile.read(content_length)
            request_logger.info(f'{raw_request}\r\n{raw_body.decode("utf-8")}\r\n')
        else:
            request_logger.info(raw_request)

    def send_static_response(self):
        self.send_response(200, 'OK')
        self.send_header('Content-Type', 'text/plain')
        self.end_headers()
        self.wfile.write(b'This is a benign server used for testing cups-browsed vulnerability CVE-2024-47176')

    def do_GET(self):
        self.send_static_response()

    def do_POST(self):
        if self.path.startswith('/printers/'):
            ip, port = self.client_address
            cups_logger.info(f'received callback from vulnerable device: {ip} - {self.headers.get("User-Agent", "Unknown")}')
            self.log_raw_request()

        self.send_static_response()

class CupsCallbackHTTPServer(HTTPServer):
    def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True, use_ssl=False):
        super().__init__(server_address, RequestHandlerClass, bind_and_activate)
        if use_ssl:
            self.socket = ssl.wrap_socket(self.socket,
                                          server_side=True,
                                          certfile='path/to/cert.pem',
                                          keyfile='path/to/key.pem',
                                          ssl_version=ssl.PROTOCOL_TLS)

    def shutdown(self):
        logging.info('Shutting down the server...')
        super().shutdown()

def start_server(callback_server, use_ssl=False):
    host, port = callback_server.split(':')
    port = int(port)

    if port < 1 or port > 65535:
        raise RuntimeError(f'invalid callback server port: {port}')

    server_address = (host, port)
    _httpd = CupsCallbackHTTPServer(server_address, CupsCallbackRequest, use_ssl=use_ssl)
    logging.info(f'callback server running on {"https" if use_ssl else "http"}://{host}:{port}...')

    server_thread = threading.Thread(target=_httpd.serve_forever)
    server_thread.daemon = True
    server_thread.start()

    return _httpd

def scan_range(ip_range, callback_server):
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_callback = f'0 3 http://{callback_server}/printers/cups_vulnerability_scan'.encode('utf-8')
    ip_range = list(ipaddress.ip_network(ip_range))

    if len(ip_range) < 1:
        raise RuntimeError("error: invalid ip range")

    logging.info(f'scanning range: {ip_range[0]} - {ip_range[-1]}')

    for ip in ip_range:
        ip = str(ip)
        try:
            udp_socket.sendto(udp_callback, (ip, 631))
            logging.debug(f'Sent callback to {ip}')
        except socket.error as e:
            logging.error(f"Error sending to {ip}: {e}")

def concurrent_scan(target_ranges, callback_server, max_workers=10):
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        executor.map(lambda target: scan_range(target, callback_server), target_ranges)

def signal_handler(signal, frame, httpd):
    logging.info('Shutting down server...')
    httpd.shutdown()
    sys.exit(0)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        prog='python3 cups_scanner.py',
        description='Uses the callback mechanism of CVE-2024-47176 to identify vulnerable cups-browsed instances',
        usage='python3 cups_scanner.py --targets 192.168.0.0/24 --callback 192.168.0.1:1337'
    )

    parser.add_argument('--callback', required=True, dest='callback_server',
                        help='the host:port to host the callback server on (must be reachable from target network) '
                             'example: --callback 192.168.0.1:1337')

    parser.add_argument('--targets', required=True, dest='target_ranges',
                        help='a comma separated list of ranges '
                             'example: --targets 192.168.0.0/24,10.0.0.0/8')

    parser.add_argument('--verbose', action='store_true', help='enable verbose output')
    parser.add_argument('--ssl', action='store_true', help='use HTTPS for the callback server')
    parser.add_argument('--workers', type=int, default=10, help='number of worker threads for scanning')

    args = parser.parse_args()

    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(level=log_level, format='%(asctime)s - %(levelname)s - %(message)s')

    try:
        logging.info(f'starting callback server on {args.callback_server}')
        httpd = start_server(args.callback_server, use_ssl=args.ssl)
        signal.signal(signal.SIGINT, lambda sig, frame: signal_handler(sig, frame, httpd))

        targets = args.target_ranges.split(',')
        logging.info('starting concurrent scan')
        concurrent_scan(targets, args.callback_server, max_workers=args.workers)

        logging.info('scan done, use CTRL + C to stop server')
        while True:
            time.sleep(1)

    except RuntimeError as e:
        logging.error(e)
    except Exception as e:
        logging.exception(f"An unexpected error occurred: {e}")
    finally:
        logging.info("Exiting the program")
